# TIL - 0428📦

## 독학사 데이터베이스
교재 1독, 병행제어와 회복 파트 설명 빈약<br> 
교재 개념 중심으로 정리해나가면서 SQLD 공부로 보강하기<br>

## 소프트웨어 장인
완독. 중복없이 명료한 태도를 가지자. 열정이 전부다.<br>
비효율성이 초래될 때 고려해야 할 2가지<br>
1. 정말 필요한 일인가?
2. 시간 안에 가능한 일인가?

문제해결을 위해 적극적으로 선택하고 선택에 대한 책임을 져야 한다.<br>
당장의 불안을 해소하기 위해 타성적으로 내리는 결정은 잘못된 결정일 확률이 높다.<br>

## 비트연산, 유클리드 호제법, 2진 최대공약수 복습 

\>> logical left shift, << Arithmetic right shift<br>
로지컬 쉬프트는 부호에 관계 없이 계속해서 0을 채워넣기 때문에 계속 반복하면 0을 향해간다.<br>
산술 쉬프트는 부호에 1을 채워넣고 이동하기에 반복 시 정수 최대값을 향해 나아간다.<br>
비트 연산에는 &, |, ^ 등이 있으며 이 연산들을 활용해 특정 값의 특정 인덱스에 있는 수를 반환하거나<br>
값을 빼거나 더할 수 있다. 예를 들어 134라는 십진수를 이진수로 표현하면 10000110이다.<br>
만약 이때 134(2)의 i번째 인덱스가 0인지 1인지 알고 싶다면 if(134 & 1 >> i) return 1;로 활용할 수 있다.<br>
운영체제나 임베디드 시스템, 네트워크 등 메모리 공간이 한정적이거나 빠른 속도를 요구하는 환경에서 활용된다고 한다.<br>
메모리 효율성을 높일 수 있지만 가독성을 떨어뜨리고 코드를 난해하게 만들 수 있을 것 같다.<br>

유클리드 호제법<br>
A % B = r(A > B)이고 #(최대공약수 연산자라고 가정)일때,<br>
A # B = B # r 이 성립하는 원칙을 이용해 최대공약수를 구할 수 있다.<br>
ex) A = 128이고 B = 96일때, 128 % 96 = r = 32, 다시 96 % 32 = r2 = 0, r2가 0 일때, 32 % 0 = 32 이므로<br>
128과 96의 최대 공약수는 32이다.<br>

2진 최대공약수(Binary GCD algorithm, Stein's algorithm)<br>
기본 아이디어는 (A > B > 0)일때 A와 B가 모두 짝수인 경우 2가 A, B의 공약수라는 데서 출발한다.<br>
1.위 아이디어를 식으로 표현하면 A # B = 2 * (A / 2) # 2 * (B / 2)이다.<br>
2.만약 A는 짝수이고 B는 홀수일 경우 A # B = (A / 2) # B임을 이용할 수도 있다.<br>
어느 한쪽만 짝수일 경우 짝수의 약수인 2는 공약수가 될 수 없기 때문이다. <br>
3.만약 A와 B 모두 홀수이면 A # B = (| A - B |) # min(A, B) 임을 이용한다.<br> 
두 홀수의 차는 항상 짝수임을 이용한 식이다.<br>
1, 2, 3의 식을 활용해 A = B 이거나 B = 0이 될 때까지 반복한다.<br>
만약 A와 B가 모두 2로 나누어지는 경우 그 수를 카운팅한다. 카운팅 값이 k라면 결과값은<br>
2^k\*A(마지막에 남아있던 수)가 된다. 2가 k번 나눠졌으므로 2^k는 A와 B의 공약수에 포함되기 때문이다.<br>
O(log(min(A, B)))의 시간 복잡도를 가지며 O(logN)의 시간복잡도인 유클리드 호제법보다 60%정도 빠르다고 한다.<br>
유클리드 호제법의 나눗셈 연산을 쉬프트 연산으로 바꿔 연산 효율을 높인 알고리즘이라고 한다.<br>
나눗셈 연산과 비트 연산의 차이와 자세한 효율 차이는 논리회로와 컴퓨터 구조론을 공부하면서 더 자세히 하도록 하자.<br>

## 자료구조 큐, 트리, 힙, 우선순위 큐 복습
열혈 자료구조 252~371p

