# Spring 정리 - 0627(기본 키 매핑과 연관관계 매핑)

## @GeneratedValue
strategy 옵션에 따라 다양한 Data 를 자동생성할 수 있다.  
strategy = GenerationType.IDENTITY 는 DB에 데이터 생성을 위임한다.  
IDENTITY는 PK조회를 위해 영속성 관리 도중에(커밋 이전) 인서트 쿼리를 전송하는 특징을 가진다.
strategy = GenerationType.SEQUENCE 에서 SEQUENCE는 유일한 값을 순서대로 생성하는 DB 오브젝트이다.  
@SequenceGenerator를 통해 클래스에 시퀀스 이름을 등록하고 사용할 수 있다.  
allocationSize를 통해 성능 최적화도 가능하다.  
strategy = GenerationType.TABLE 은 키 생성 테이블을 하나 만들어 DB 시퀀스를 흉내내는 전략이다.  
모든 DB에 적용할 수 있지만 성능 이슈가 있다.


## 식별자 전략
기본키 제약 조건은 null이 아니어야 하며 불변해야 한다.  
자연키가 아닌 대체키를 사용하자. -> Long + 대체키 + 키 생성전략  

## 데이터 중심 설계의 문제점
직접 조인할 것도 아닌데 테이블의 외래키를 그대로 가져온다.  
객체 그래프 탐색도 불가능하다. 객체지향적으로 DB를 설계하려면 엔티티에 외래키가 아닌 객체 참조를 넣어야 한다.  
객체지향적 설계는 자율적인 객체들의 협력 공동체를 구성하는 일이다.     
  
## 1:1, N:1, N:M 연관관계
@OneToOne, @ManyToOne, @ManyToMany 등의 어노테이션으로 연관관계를 등록하고 @JoinColumn(name = "Member\_ID")와 같이  
조인할 칼럼을 넣어준다.  

## 중요. 양방향 연관관계와 연관관계의 주인  
해당 개념을 이해하기 위해서 우선 객체 참조와 테이블 참조의 차이를 이해해야 한다.  
테이블 참조는 사실상 FK로 연결된 순간부터 양방향 연관관계가 성립된다. 외래키를 가진 테이블은 외래키로,  
PK를 전달하는 테이블은 PK로 조인해 서로의 데이터를 참조할 수 있다.  
그러나 객체 참조 과정은 한 객체가 다른 객체의 타입으로 변수를 생성한다. 그러므로 FK를 제공하는 객체는 자신의 PK만으로 상대 객체를 참조할 수 없다.  
객체로서 상대 객체를 참조하기 위해서는 상대 객체에 해당하는 타입의 인스턴스를 만들어야 한다.  
만약 FK-PK 간에 다대일 관계가 성립하는 경우 FK를 가진 객체는 상대를 상대 타입 객체로 참조하고 PK를 가진 객체는 상대 타입의 제네릭을 가지는 연속된 자료형(ex. List)으로 상대를 참조할 수 있다.  
  
(mappedBy = "variable")을 이해하는 게 핵심이다.  
위의 차이를 통해 객체의 양방향 관계는 사실상 두 개의 단방향 연관관계라는 사실을 알 수 있다.  
이에 따른 결과로 두 개의 객체가 DB상 하나의 데이터를 공통으로 다루게 된다.  
두 개의 객체 중 어느 한 쪽에서 값을 CRUD 했을 때 다른 객체에도 동일한 작업이 이뤄져야 하는데 이는 중복이므로  
원천적으로 한 쪽에만 등록/수정 조건을 일임하고 다른 쪽은 읽기 권한만 부여하게 하는데 이때 등록/수정 조건을 가지는 객체를 연관관계의 주인이라고 표현한다.  
mappedBy 속성은 주인이 아닌 쪽의 객체에 지정되며 주인은 mappedBy를 사용하지 않는다.  
  
그렇다면 어떤 객체를 주인으로 정할까?  
외래키를(Many쪽인) 가진 쪽을 주인으로 정하면 된다.  
반대의 경우 직관적이지 않고 성능이슈도 있다.  
  
## 양방향 매핑시 가장 많이 하는 실수
-> 연관관계의 주인을 비즈니스 로직을 기준으로 정한다.  
연관관계의 주인은 비즈니스 로직과 관계없이 외래키를 가진 쪽이다.
-> 연관관계의 주인에 값을 입력하지 않음  
역방향에 값을 세팅해놓고 DB에 반영되지 않아 고민한다.  
-> 해결방안 + 영속성 컨텍스트를 고려해서 항상 양방향 모두에 값을 세팅하는 방법도 있다.  
주인에만 값을 세팅하면 INSERT 쿼리를 날리기 전까지는 값이 1차 캐시에만 저장된다. 컨텍스트 도중에 flush(), clear()를 실행하지 않으면 주인이 아닌 쪽의 데이터를 DB에서 조회할 수 없기 때문에 양방향으로 세팅하는 게 좋다.  
하지만 위에서 말했듯이 작업이 중복되므로 Setter가 아닌 연관관계 편의 메서드(자바 관례상 Setter는 setter로만 쓰는 게 좋다.)를 만들어 양쪽에 값을 설정하자.    
  
-> 무한 루프 주의
toString()메서드를 양방향에 놓으면 서로 호출하며 무한 루프를 돌 수도 있다.  
Lombok, JSON 생성 라이브러리 등을 사용할 때 주의해야 한다.  
Controller에서는 되도록 Entity를 그대로 반환하지 않는다.  
  
## 양방향 매핑 정리
처음에는 무조건 단방향 매핑으로 설계를 끝낸다.  
양방향 매핑은 반대 방향 조회(객체그래프 탐색) 기능이 추가된 것 뿐이라고 생각한다.  
일단은 단방향 매핑을 잘 하고 양방향은 JPQL에서 역방향으로 탐색을 한다거나 다른 필요한 일이 생길 때 추가하면 된다.  
테이블에 영향을 주지 않기 때문이다.  
  

## 일대다 단방향 매핑
실무에서 잘 쓰이지는 않지만 가끔 쓰일 때도 있다. 일대다 관계에서 1이 주인인 관계가 됨으로 1쪽 객체가 다쪽 객체의 객체 참조를 갖지만 실제 DB에 데이터를 반영할 때는 다쪽의 테이블에 반영한다. @JoinColumn을 사용하지 않으면 중간에 새 테이블이 생성되므로 꼭 써주자.  
가끔 일대다 양방향 매핑을 써야 할 때도 있는데 읽기 전용 필드를 사용해 양방향처럼 사용하는 방법이다.  
왠만하면 다대일 양방향을 사용하자.  

  
## 1:1 매핑
다대일 단방향 매핑과 유사하다.  
  
## N:M 매핑
쓰면 안된다. 연결 테이블 엔티티를 만들어 일대다 다대일 관계로 풀어내야한다.

## @Inheritance 상속관계 매핑
객체지향적인 엔티티를 관계형 DB로 매핑하는 방법에는 3가지가 있다. 관계형 DB에는 객체지향 언어와 완벽히 일치하는 상속 관계가 없기 때문에 가장 비슷한 슈퍼타입, 서브타입 논리 모델을 기반으로 구성한다.  
주요 전략으로 조인 전략(가장 정규화 단계가 높음), 단일 테이블 전략(타입 속성으로 구분), 구현 클래스마다 테이블 전략 등이 있다.(슈퍼타입을 주지 않고 공통 속성을 중복인 채로 구현 클래스마다 테이블을 둔다.)   

## @MappedSuperclass
공통 매핑 정보만 담는 슈퍼 클래스를 만들 수 있다. @MappedSuperclass애노테이션이 붙은 슈퍼 클래스(추상 클래스 가능)를 만들고 상속해 사용한다.  
따로 DB는 존재하지 않는다. 매핑만 해주고 실제 insert 쿼리는 공통부분을 가지는 개별 테이블로 보내진다.   
실무에서도 유용하게 쓰인다.  
  
## Proxy
지연로딩에 대해 이해하려면 프록시를 이해해야 한다.  
em.find()가 DB를 통해 실제 엔티티 객체를 조회한다면 em.getReference()는 DB 조회를 미루는 가짜(프록시) 엔티티 객체를 조회한다.  
프록시 엔티티 객체란 DB에 쿼리를 전달하지 않고도 조회 가능한 객체를 말한다.  
하이버네이트가 내부의 라이브러리를 활용해 프록시라는 가짜 엔티티를 만들기에 가능하다.  
프록시 엔티티는 실제 클래스를 상속해 만들어진다. 겉 모양은 같지만 내부의 값은 null로 세팅되어 있다.  
이론적으로 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용한다.  
프록시 객체는 target을 가지고 있다. target은 실제 객체에 대한 멤버변수이다. 만약 사용자가 target을 호출한다면  
target은 영속성 컨텍스트에 초기화를 요청해 실제 DB를 조회하고 실제 엔티티를 생성해 조회를 요청한다.  
  
중요한 사실은 프록시 객체를 초기화할 때 프록시 객체가 실제 엔티티를 만들어 이를 참조하는 것이지 프록시 객체 자체가  
실제 객체로 바뀌는 것이 아니라는 것이다.  
target이 실제 객체를 가리키는 것이다. 따라서 프록시 객체는 타입 체크시 == 이 아니라 instance of를 사용해야 한다.   
  
영속성 컨텍스트 안에 실제 엔티티가 이미 있으면 getReference()를 호출해도 실제 엔티티가 호출된다.  
이미 1차 캐시에 원본이 있는데 프록시 객체를 만드는 데는 아무런 효용이 없기 때문이다.  
  
많이 하는 실수  
-> 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일때, 프록시를 초기화하는데 문제가 발생한다.  
-> org.hibernate.LazyInitializationException  
  
## 지연로딩 
지연 로딩을 사용하게 되면 객체를 프록시로 등록해뒀다가 실제 조회를 시도할 때 초기화를 진행한다.  
실무에서는 가급적 지연 로딩만 사용하자.  
-> 즉시 로딩(즉시 조인)을 적용하면 예상하지 못한 SQL이 발생할 수 있다. 과다 조인(객체가 몇 개만 얽혀도 전부 조인한다.)  
-> 즉시 로딩은 JPQL에서 N+1 문제를 일으킨다.  
  
## 영속성 전이: CASCADE
특정 엔티티를 영속 상태로 만들 때 다른 엔티티도 같이 영속 상태에 넣는 걸 영속성 전이라고 한다.  
parent 객체를 persist할 때 child 객체도 같이 persist하는 경우 영속성 전이이다. 
```java
@OneToMany(mappedBy = "parent", cascade = CascadeType.ALL)
Private List<Child> childList = new ArrayList<>();
```
parent객체가 @ManyToOne이고 child 객체의 주인 객체일때 위와 같이 cascade를 사용할 수 있다.  
사용할 만한 옵션은 ALL, PERSIST, REMOVE 정도이다.  
단일 엔티티에 완전히 종속적인 상황에서 사용하는 게 권장된다.(ex. 첨부파일 객체가 게시판 객체에 완전 종속적일 때)  
  
## 고아 객체  
고아 객체란 부모 엔티티와 연관관계가 끊어진 자식 엔티티이다. 이를 자동으로 삭제하는 게 고아 객체 제거이다.  
```java
@OneToMany(mappedBy = "parent", orphanRemoval = true)
Private List<Child> childList = new ArrayList<>();
```
위와 같이 orphanRemoval = true로 설정할 경우 childList의 참조가 제거되면 childList가 영속성 컨텍스트에서 제외된다.  
부모 객체를 제거하는 상황에도 CASCADE로 자식 객체가 삭제된다. 특정 엔티티가 하나의 엔티티 소유일 때 사용된다.  
  
CascadeType.ALL + orphanRemoval = true  
를 동시에 활성화하는 경우 부모 엔티티를 통해 자식 엔티티의 생명 주기를 관리할 수 있다.  
도메인 주도 설계(DDD)의 Aggregate Root라는 개념을 구현할 때 유용하다.  
  
## JPA의 값 타입
최상위 구분은 @Entity로 관리되는 엔티티 타입(@Id 식별자를 통해 변경값 추적)과 값이 변하면 추적할 수 없는 기본값 타입(자바의 기본, 래퍼 타입 그 자체)가 있다.  
기본값 타입, 임베디드 타입(복합 값 타입), 컬렉션 값 타입으로 구분할 수도 있다.  
  
## 기본값 타입의 주요 특징  
생명주기를 엔티티에 의존한다, 값 타입은 절대로 공유하지 않는다.(Side Effect)  
원래 자바의 primitive type은 절대 공유되지 않는다. 
```java
int a = 10;
int b = a;

a = 20;
```
의 결과는 항상 다르다. 변수의 값을 다른 변수로 할당한다고 해도 이는 다른 변수의 복사값일 뿐이지 다른 변수의  
메모리 주소 그 자체가 아니다.  
```java
Integer a = new Integer(10);
Integer b = a;

a.setValue(20);
```
그러나 만약 setValue(int number)라는 메서드가 있어서 Integer의 값을 초기화할 수 있다면 위 코드의 a는 b와 같은 객체를 참조하므로 둘 다 20이 된다. 하지만 setValue와 같은 메서드는 임의로 만들지 않는 이상 존재하지 않는다.  
따라서 위와 같은 상황이 발생할 일은 거의 없으므로 기본값 타입을 활용하면 안정적인 개발을 할 수 있다.  
당연한 사실이지만 임베디드 타입을 공부하기 위해 기본값 타입에 관해 확실히 이해하고 넘어가야 한다.  
  
## 임베디드 타입  
값타입의 집합이다. JPA를 위한 구조체라고 생각하자.  
재사용성, 높은 응집도, Period.isWork()처럼 해당 값타입만 사용하는 메소드를 만들 수 있음 등이 장점이다.  
구조체이니 값타입과 마찬가지로 엔티티에게 생명주기를 의존한다.

임베디드 타입을 정의하는 클래스에는 @Embeddable, 쓰는 곳에서는 @Embedded 애노테이션을 써준다. 기본 생성자는 필수다.  
  
한 엔티티에서 같은 값 타입을 사용하려면 @AttributeOverride를 사용해 컬럼명을 재정의해준다.  
또 임베디드 타입 값 자체가 null이면 매핑한 칼럼값도 모두 null이다.  
  
## 값 타입과 불변객체  
값 타입의 공유 참조  
-> 값 타입을 공유하는 엔티티 A, B가 있을 때 한 쪽에서 값 타입의 데이터를 변경하면 공동으로 데이터가 변경되는 문제가 발생한다. 의도적으로 여러 객체가 데이터를 공유하려면 엔티티를 사용하거나 변경하려는 값을 복사한 객체를 사용해야 한다. 값 타입은 값 참조 객체 타입은 포인터 참조라고 생각하자. 객체 타입의 직접 참조로 인한 부작용을 원천적으로 차단하기 위해 객체 타입을 불변 객체로 만드는 방안이 있다. 불변 객체는 세터가 없기 때문에 만약 값을 바꾸고 싶다면 새 객체를 만들어 해당 값을 변경한 뒤 주입해야 한다. Integer와 String은 자바의 대표적인불변객체이다.  

## 값 타입의 비교  
동일성 비교(Identity) : ==  
동등성 비교(Equivalence) : equals()  
기본 equals()는 == 밖에 없어서 오버라이드 해서 사용해야 한다. 오버라이드도 IDE에서 기본으로 제공하는 형식대로 하면 된다.<br>
==는 값 타입의 경우에는 값을 비교하지만 오브젝트 타입은 객체 메모리를 비교한다. 따라서 동일값을 가진 두 객체를 비교하면 false가 나온다.<br>
String으로 만들어진 문자열을 == 로 비교하는 경우에도 String 변수 자체가 객체이다 보니 == 를 사용하면 false가 나올 수 있다.(String은 예외적으로  ==가 허용될 때도 있지만 일반적으로는 equals()를 사용해 비교한다.)

