# 테이블과 해쉬

## 해쉬 함수와 해쉬 충돌, 선형, 이차 조사법
키와 일치하는 밸류값을 갖는 자료 구조로 구조체는 자신의 키에 해당하는 값을 자신의 인덱스로 갖는다.  
데이터베이스의 고유키와 마찬가지로 해쉬 함수의 키는 독립적이고 식별가능하며 유일해야 한다.  
키를 할당하기 위해 주어진 입력값에 특정 함수를 적용시켜 키를 추출하는데 이 함수를 해쉬 함수라고 한다.  
해쉬값은 충돌할 수 있다.  
따라서 해쉬값의 충돌을 피하고자 등장한 개념이 조사법이다.  
해쉬값이 충돌하는 경우 해당 값을 기준으로 한 인덱스씩 멀어지는 방법이 선형 조사법이고 n^2씩 멀어지는 방법이 이차 조사법이다.  
선형 조사법은 해쉬값이 특정 인덱스 주변으로 집중될 여지가 있다. 해쉬값의 분포는 어느 한 곳에 치우치지 않고 고르게 분포하는 게 이상적이다.  
해쉬값의 범위를 넓히기 위해서는 이차 조사법이 유리하지만 이차 조사법에도 나름의 문제가 있다.(이중 해쉬)  
  
## 해쉬 상태의 세 종류 INUSE, EMPTY, DELETED
해쉬 상태에 사용중과 삭제 외에 DELETED 따로 두는 이유는 해쉬 충돌 여부를 파악하기 위함이다.  
새 해쉬값을 할당해 EMPTY한 곳에 배치했는데 해당 공간을 포함한 주변이 이미 여러 번 할당된 값의 범위에 해당될 수 있다.  
하지만 해당 인덱스의 상태가 EMPTY이면 해쉬 충돌을 의심하지 않고 함수의 무결성을 믿게 된다.  
이는 추후의 빈번한 해쉬 충돌로 이어질 수 있다.  
따라서 한 번이라도 값이 할당되었다면 해당 인덱스에서 값을 삭제할 경우 DELETED 상태로 두어 해쉬값이 할당된 적이 있음을 드러내야 한다.  
  
## 이중 해쉬
이차 탐색을 통해 n^2 범위로 해쉬 값을 할당한다고 해도 여전히 n^2이라는 해쉬 집중 구간이 발생한다.  
때문에 해쉬 집중 구간의 범위를 더 넓히고자 등장한 방식이 이중 해쉬이다. 이중 해쉬 설정은 아래와 비슷하다.  
1차 해쉬 함수 -> hf1(k) = k % 15  
2차 해쉬 함수 -> hf2(k) = 1 + (k % c)  
여기서 상수 c의 값은 1차 해쉬 함수의 나머지 피연산자보다 작은 소수 중 하나로 결정한다.  
여기에 1을 더하는 이유는 결괏값이 0이 아니게 하기 위함이다.  
소수를 설정하는 이유는 소수를 설정했을 때 클러스터 현상의 발생 확률을 현저히 줄일 수 있다는 통계에 근거한 것이다.  
간단한 예를 들어보자  
hf1(3) = 3 % 15 = 3  
hf1(18) = 18 % 15 = 3  
hf1(33) = 33 % 15 = 3  
위 값들은 모두 동일한 값을 내 충돌한다. 이 값들을 대상으로 2차 해쉬값을 내면 아래와 같다.  
hf2(18) = 1 + 18 % 7 = 5  
hf2(33) = 1 + 33 % 7 = 6   
이제 이 2차 해쉬 값을 가지고 다시 2차 조사법을 진행하면 각자 다른 n으로 n^2을 진행할 수 있게 된다.  
hf2(18) -> hf2(18) + 5 * 1 -> hf2(18) + 5 * 2 -> hf2(18) + 5 * 3...  
hf2(33) -> hf2(33) + 6 * 1 -> hf2(33) + 6 * 2 -> hf2(33) + 6 * 3...  
  
## 체이닝
위 방법들은 열린 어드레싱 방법(Open Addressing Method)에 해당한다.  
충돌이 발생하면 다른 자리에 값을 저장한다는 의미이다.  
체이닝은 닫힌 어드레싱 방법에 해당한다. 따라서 체이닝은 무슨 일이 있어도 값을 해당 자리에 저장한다.  
충돌이 있어도 값을 그 자리에 그대로 저장한다는 의미이다.  
체이닝이라는 말처럼 값을 연결 리스트로 연쇄적으로 묶어 해당 인덱스에 여러 개의 값이 공존할 수 있게 한다.  

